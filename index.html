<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TapMap</title>
    <meta name="description" content="A classic D&D grid mapper with doors, enemies, stairs, etc." />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    <link rel="stylesheet" href="https://nagoshiashumari.github.io/Rpg-Awesome/stylesheets/rpg-awesome.min.css" />
    <style>
/* Base Styles */
body {
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;
    touch-action: manipulation;
    user-select: none;
    overflow: hidden;
}

/* Grid Layout */
#map-area {
    position: relative;
    width: 100%;
    height: 100vh;
    overflow: hidden;
}

#grid-container {
    position: absolute;
    top: 20px;
    left: 20px;
    right: 0;
    bottom: 0;
    overflow: hidden;
    z-index: 1000;
}

#grid {
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: 0 0;
}

/* Cell Base Styles */
.cell {
    width: 40px;
    height: 40px;
    border: 1px solid #ccc;
    position: absolute;
    box-sizing: border-box;
}

/* Filled Cell Styles */
.cell.filled {
    background-color: #87cefa;
}

.cell.filled::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #87cefa;
    border: 2px solid black;
    pointer-events: none;
    z-index: 1;
}

/* Connected Cell Borders */
.cell.filled.connected-left::before {
    border-left: none !important;
}

.cell.filled.connected-right::before {
    border-right: none !important;
}

.cell.filled.connected-top::before {
    border-top: none !important;
}

.cell.filled.connected-bottom::before {
    border-bottom: none !important;
}

/* Diagonal Cell Base Styles */
.cell.diagonal-ne,
.cell.diagonal-se,
.cell.diagonal-sw,
.cell.diagonal-nw {
    position: absolute !important;
    transform: none !important;
    width: 40px !important;
    height: 40px !important;
    box-sizing: border-box !important;
    border: 1px solid #ccc !important;
}

/* Diagonal Gradients */
.cell.diagonal-ne {
    background: linear-gradient(45deg,
        #ffffff 49%,
        #000000 49% 51%,
        #87cefa 51%
    ) !important;
}

.cell.diagonal-se {
    background: linear-gradient(135deg,
        #ffffff 49%,
        #000000 49% 51%,
        #87cefa 51%
    ) !important;
}

.cell.diagonal-sw {
    background: linear-gradient(-135deg,
        #ffffff 49%,
        #000000 49% 51%,
        #87cefa 51%
    ) !important;
}

.cell.diagonal-nw {
    background: linear-gradient(-45deg,
        #ffffff 49%,
        #000000 49% 51%,
        #87cefa 51%
    ) !important;
}
/* edge cases */
.cell.diagonal-ne-edge,
    .cell.diagonal-nw-edge,
    .cell.diagonal-se-edge,
    .cell.diagonal-sw-edge {
        border-color: #000 !important;
    }

/* Icon Base Styles */
.cell i {
    position: absolute !important;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    z-index: 100 !important;
    pointer-events: none;
    color: black;
    text-shadow: 1px 1px 1px white;
}

/* Diagonal Icon Positioning */
.cell.diagonal-ne i {
    top: 25% !important;
    left: 75% !important;
    font-size: 16px !important;
}

.cell.diagonal-se i {
    top: 75% !important;
    left: 75% !important;
    font-size: 16px !important;
}

.cell.diagonal-sw i {
    top: 75% !important;
    left: 25% !important;
    font-size: 16px !important;
}

.cell.diagonal-nw i {
    top: 25% !important;
    left: 25% !important;
    font-size: 16px !important;
}

/* Secret Element Styles */
.secret-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    z-index: 10;
}

.secret-element .secret-container {
    position: relative;
    width: 100%;
    height: 100%;
}

.secret-element .secret-container::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.7);
    z-index: 1;
}

.secret-element .secret-container i {
    position: relative;
    z-index: 102;
}

.secret-element.revealed .secret-container::after {
    display: none;
}

/* FAB Menu Styles */
.fab {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background-color: #2196f3;
    color: white;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    text-align: center;
    line-height: 56px;
    font-size: 24px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    z-index: 1000;
}
/* FAB Menu Layout */
.fab-menu {
    position: fixed;
    bottom: 80px;
    right: 20px;
    display: none;
    flex-direction: column;
    align-items: flex-end;
    z-index: 1000;
}

.fab-submenu {
    display: none;
    margin-right: 10px;
}

/* FAB Items */
.fab-item {
    background-color: #1e88e5;
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    text-align: center;
    margin-bottom: 10px;
    cursor: pointer;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}

.fab-item i {
    font-size: 24px !important;
    position: relative !important;
    transform: none !important;
    top: auto !important;
    left: auto !important;
}

.fab-item i.ra {
    font-size: 20px !important;
}

.fab-item.red {
    background-color: #e53935;
}

.fab-item.yellow {
    background-color: #ffc107;
}

/* Rotating FAB Buttons */
.diagonal-rotate-fab,
.elements-rotate-fab {
    position: fixed;
    bottom: 20px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: #1e88e5;
    color: white;
    display: none;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    transition: background-color 0.3s ease;
}

.diagonal-rotate-fab {
    right: 90px;
}

.elements-rotate-fab {
    right: 160px;
}

.diagonal-rotate-fab i,
.elements-rotate-fab i {
    font-size: 24px !important;
    position: relative !important;
    transform: none !important;
}

.elements-rotate-fab i {
    font-size: 20px;
}

.diagonal-rotate-fab.active,
.elements-rotate-fab.active {
    background-color: #4caf50;
}

/* Grid Labels and Coordinates */
.grid-label {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(255, 255, 255, 0.7);
}

.coordinate-label {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: bold;
    color: #333;
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    overflow: hidden;
    white-space: nowrap;
}

/* Legend Styles */
/* Update your legend styles */
.legend {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    max-width: 300px;
    padding: 20px;
    background-color: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    z-index: 2500; /* Higher than other elements */
    display: none; /* Initial state */
}

.legend-section {
    margin-bottom: 15px;
}

.legend-section h4 {
    margin: 0 0 8px 0;
    color: #2196f3;
    font-size: 16px;
}

.legend-section ul {
    margin: 0;
    padding-left: 20px;
}

.legend-section li {
    margin: 5px 0;
    font-size: 14px;
    line-height: 1.4;
}

.fab-item.blue {
    background-color: #2196f3;
}

/* Start Menu */
#startMenu {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    z-index: 2000;
}

#startMenu button {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 18px;
    cursor: pointer;
}
/* Notes Overlay */
.notes-overlay {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 300px;
    height: 400px;
    background-color: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    display: none;
    flex-direction: column;
    z-index: 1500;
    padding: 15px;
    resize: both;
    overflow: auto;
    min-width: 200px;
    min-height: 200px;
}

.notes-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    cursor: move;
    padding: 5px;
    background-color: #f5f5f5;
    border-radius: 4px;
}

.notes-title {
    margin: 0;
    font-size: 16px;
    font-weight: bold;
}

.notes-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.notes-textarea {
    width: 100%;
    height: 100%;
    resize: none;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 8px;
    font-family: Arial, sans-serif;
    font-size: 14px;
    line-height: 1.5;
}

.notes-textarea:focus {
    outline: none;
    border-color: #2196f3;
}

.notes-display {
    width: 100%;
    height: 100%;
    resize: none;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 8px;
    font-family: Arial, sans-serif;
    font-size: 14px;
    line-height: 1.5;
    overflow-y: auto;
    white-space: pre-wrap;
}

.notes-display:focus {
    outline: none;
    border-color: #2196f3;
}

/* Reference dot indicator */
.cell .reference-dot {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 8px;
    height: 8px;
    background-color: #ff4081;
    border-radius: 50%;
    z-index: 150;
    display: none;
}
.reference-dot {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    z-index: 150;
    display: none;
    box-shadow: 0 0 2px rgba(0,0,0,0.5); /* Makes dots more visible */
}

/* Style for the color cycle button */
#cycleColor {
    transition: background-color 0.3s ease;
}

/* Style for colored coordinates in textarea */
.notes-textarea span {
    display: inline;
    padding: 0 2px;
}

/* Quick actions bar in notes */
.notes-quick-actions {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
    padding: 5px;
    background-color: #f5f5f5;
    border-radius: 4px;
}

.quick-action-btn {
    padding: 4px 8px;
    border: none;
    border-radius: 4px;
    background-color: #2196f3;
    color: white;
    cursor: pointer;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 4px;
}

.quick-action-btn:hover {
    background-color: #1976d2;
}

.quick-action-btn i {
    font-size: 16px;
}

    </style>
</head>

<body>
    <div id="startMenu">
        <h1>TapMap</h1>
        <p>
            Tap grid squares to fill them. Use the menu to add doors, enemies,
            stairs, etc.
        </p>
        <button id="readyBtn">Ready</button>
    </div>
    <div id="map-area">
        <div id="grid-container">
            <div id="grid"></div>
        </div>
    </div>
    <div class="fab" id="fabBtn">+</div>
    <div class="fab-menu" id="fabMenu"></div>

    <div id="legend" class="legend" style="display: none;">
        <h3>Map Legend</h3>
        <div id="legendContent"></div>
    </div>
    <script>
        // DOM Elements
        const grid = document.getElementById('grid')
        const gridContainer = document.getElementById('grid-container')
        gridContainer.style.display = 'block'
        const fabMenu = document.getElementById('fabMenu')
        const fabBtn = document.getElementById('fabBtn')
        const startMenu = document.getElementById('startMenu')
        const readyBtn = document.getElementById('readyBtn')

        // Grid Configuration
        let currentMode = 'fill'
        let mapData = []
        let scale = 1
        let translateX = 0
        let translateY = 0
        let isDragging = false
        let lastX, lastY
        let isDiagonalModeActive = false
        let activeDiagonalDirection = ''
        const cellSize = 40
        const gridSize = 100
        const totalGridSize = gridSize * cellSize
        const cells = new Map()
        let activeElementType = null // Stores the currently active element type
        let isMiddleMouseDown = false;
let lastMiddleX = 0;
let lastMiddleY = 0;
let notes = '';
let isDraggingNotes = false;
let notesStartX, notesStartY;
let isNotepadOpen = false;
let referencedCells = new Set();

        // FAB Menu Configuration
        const menuItems = [
    { id: 'mapElements', icon: { ra: 'ra-castle-flag', material: 'map' }, submenu: [
        { id: 'addDoor', icon: { ra: 'ra-wooden-door', material: 'door_front' } },
        { id: 'addSecretDoor', icon: { ra: 'ra-secret-door', material: 'door_sliding' } },
        { id: 'markEnemy', icon: { ra: 'ra-dragon', material: 'pest_control' } },
        { id: 'markStairs', icon: { ra: 'ra-tower', material: 'stairs' } },
        { id: 'addTrap', icon: { ra: 'ra-spikes-full', material: 'warning' } },
        { id: 'addNpc', icon: { ra: 'ra-player', material: 'person' } },
        { id: 'addTreasure', icon: { ra: 'ra-treasure-map', material: 'attach_money' } }
    ]},
    { id: 'diagonalPath', icon: { material: 'call_split' }, submenu: [
        { id: 'diagonalPathNE', icon: { material: 'north_east' } },
        { id: 'diagonalPathSE', icon: { material: 'south_east' } },
        { id: 'diagonalPathSW', icon: { material: 'south_west' } },
        { id: 'diagonalPathNW', icon: { material: 'north_west' } }
    ]},
    { id: 'eraser', icon: { ra: 'ra-eraser', material: 'auto_fix_high' }, class: 'yellow' },
    { id: 'toggleLegend', icon: { material: 'help_outline' }, class: 'blue' },
    { id: 'saveMap', icon: { ra: 'ra-save', material: 'save' }, class: 'red' },
    { id: 'loadMap', icon: { ra: 'ra-folder', material: 'folder_open' }, class: 'red' }
];

        let diagonalDirections = ['NE', 'SE', 'SW', 'NW']
        let currentDiagonalIndex = 0
        let elementTypes = [
            'door',
            'secretdoor',
            'enemy',
            'stairs',
            'trap',
            'npc',
            'treasure'
        ]
        let currentElementIndex = 0
        let isElementModeActive = false

        const iconMap = {
            door: { ra: 'ra-wooden-door', material: 'door_front' },
            secretdoor: { ra: 'ra-secret-door', material: 'door_sliding' },
            enemy: { ra: 'ra-dragon', material: 'pest_control' },
            stairs: { ra: 'ra-tower', material: 'stairs' },
            trap: { ra: 'ra-spikes-full', material: 'warning' },
            npc: { ra: 'ra-player', material: 'person' },
            treasure: { ra: 'ra-treasure-map', material: 'attach_money' }
        }
        // const legendItems = [
        //     { type: 'door', label: 'Door' },
        //     { type: 'secretdoor', label: 'Secret Door' },
        //     { type: 'enemy', label: 'Enemy' },
        //     { type: 'stairs', label: 'Stairs' },
        //     { type: 'trap', label: 'Trap' },
        //     { type: 'npc', label: 'NPC' },
        //     { type: 'treasure', label: 'Treasure' }
        // ]
        const dotColors = [
    '#FF0000', // Red
    '#00FF00', // Green
    '#0000FF', // Blue
    '#FFA500', // Orange
    '#800080', // Purple
    '#FFC0CB', // Pink
    '#FFD700', // Gold
    '#00FFFF', // Cyan
    '#FF00FF', // Magenta
    '#008000', // Dark Green
    '#800000', // Maroon
    '#000080'  // Navy
];
let currentColorIndex = 0;

        const legendContent = `
<div class="legend-section">
    <h4>Basic Controls</h4>
    <ul>
        <li>Click squares to fill them</li>
        <li>Drag to pan the map</li>
        <li>Mouse wheel to zoom</li>
        <li>Use eraser to remove elements</li>
    </ul>
</div>

<div class="legend-section">
    <h4>Map Elements</h4>
    <ul>
        <li>Click Map Elements (üè∞) to show placement menu</li>
        <li>Select element type to place</li>
        <li>Click again on Map Elements to exit placement mode</li>
        <li>Quick select: Use the rotating element button when active</li>
    </ul>
</div>

<div class="legend-section">
    <h4>Diagonal Walls</h4>
    <ul>
        <li>Click Diagonal (‚Üó) to enter diagonal mode</li>
        <li>Use the rotating button to change direction</li>
        <li>Click again on Diagonal to exit</li>
    </ul>
</div>

<div class="legend-section">
    <h4>Special Features</h4>
    <ul>
        <li>Secret doors/traps are hidden until clicked</li>
        <li>Click Save (üíæ) to download your map</li>
        <li>Click Load (üìÅ) to restore a saved map</li>
    </ul>
</div>
`;

function cycleColor() {
    currentColorIndex = (currentColorIndex + 1) % dotColors.length;
    updateColorButton();
    return dotColors[currentColorIndex];
}

// Add this function to update the color button appearance
function updateColorButton() {
    const colorBtn = document.querySelector('#cycleColor');
    if (colorBtn) {
        colorBtn.style.backgroundColor = dotColors[currentColorIndex];
    }
}
function createNotesOverlay() {
    const overlay = document.createElement('div');
    overlay.className = 'notes-overlay';
    overlay.innerHTML = `
        <div class="notes-header">
            <h3 class="notes-title">Notes</h3>
            <div class="notes-controls">
                <button class="fab-item" style="width: 30px; height: 30px;" id="closeNotes">
                    <i class="material-icons" style="font-size: 18px;">close</i>
                </button>
            </div>
        </div>
        <div class="notes-quick-actions">
            <button class="quick-action-btn" id="insertTimestamp">
                <i class="material-icons">access_time</i>Time
            </button>
            <button class="quick-action-btn" id="cycleColor" style="background-color: ${dotColors[0]}">
                <i class="material-icons">color_lens</i>Color
            </button>
            <button class="quick-action-btn" id="clearDots">
                <i class="material-icons">clear_all</i>Clear
            </button>
        </div>
        <div class="notes-content">
            <div class="notes-display" contenteditable="true">${notes}</div>
        </div>
    `;
    document.body.appendChild(overlay);

    setupNotesEventListeners(overlay);
    return overlay;
}

function setupNotesEventListeners(overlay) {
    const header = overlay.querySelector('.notes-header');
    const closeBtn = overlay.querySelector('#closeNotes');
    const insertTimeBtn = overlay.querySelector('#insertTimestamp');
    const clearDotsBtn = overlay.querySelector('#clearDots');
    const displayDiv = overlay.querySelector('.notes-display');  // Get existing displayDiv instead of creating new one

    header.addEventListener('mousedown', startDraggingNotes);
    document.addEventListener('mousemove', dragNotes);
    document.addEventListener('mouseup', stopDraggingNotes);

    closeBtn.addEventListener('click', () => {
        toggleNotesOverlay(false);
    });

    displayDiv.addEventListener('input', () => {
        notes = displayDiv.innerHTML;
    });

    insertTimeBtn.addEventListener('click', () => {
        const timestamp = new Date().toLocaleTimeString();
        insertTextAtCursor(displayDiv, `[${timestamp}] `);
    });

    clearDotsBtn.addEventListener('click', () => {
        clearReferenceDots();
    });

    const colorBtn = overlay.querySelector('#cycleColor');
    colorBtn.addEventListener('click', () => {
        cycleColor();
    });

    // Ensure display div maintains focus when clicked
    displayDiv.addEventListener('click', (e) => {
        e.stopPropagation();
        displayDiv.focus();
    });

    displayDiv.addEventListener('blur', () => {
        // Store the current selection when focus is lost
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            displayDiv.lastRange = selection.getRangeAt(0);
        }
    });

    displayDiv.addEventListener('focus', () => {
        // Restore the last selection if it exists
        if (displayDiv.lastRange) {
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(displayDiv.lastRange);
        }
    });
}

// Drag functionality
function startDraggingNotes(e) {
    const overlay = document.querySelector('.notes-overlay');
    if (e.target.closest('.notes-header')) {
        isDraggingNotes = true;
        notesStartX = e.clientX - overlay.offsetLeft;
        notesStartY = e.clientY - overlay.offsetTop;
    }
}

function dragNotes(e) {
    if (isDraggingNotes) {
        const overlay = document.querySelector('.notes-overlay');
        const newX = e.clientX - notesStartX;
        const newY = e.clientY - notesStartY;

        // Keep within window bounds
        const maxX = window.innerWidth - overlay.offsetWidth;
        const maxY = window.innerHeight - overlay.offsetHeight;
        
        overlay.style.left = `${Math.min(Math.max(0, newX), maxX)}px`;
        overlay.style.top = `${Math.min(Math.max(0, newY), maxY)}px`;
    }
}

function stopDraggingNotes() {
    isDraggingNotes = false;
}

// Toggle notes overlay visibility
function toggleNotesOverlay(show = null) {
    const overlay = document.querySelector('.notes-overlay');
    isNotepadOpen = show !== null ? show : (overlay.style.display === 'none' || !overlay.style.display);
    
    overlay.style.display = isNotepadOpen ? 'flex' : 'none';
    
    if (isNotepadOpen) {
        // Restore dots when opening notepad
        restoreReferenceDots();
    } else {
        // Hide dots when closing notepad
        document.querySelectorAll('.reference-dot').forEach(dot => {
            dot.style.display = 'none';
        });
    }
}

// Add notes button to FAB menu
function addNotesButton() {
    const notesButton = document.createElement('div');
    notesButton.className = 'fab-item';
    notesButton.id = 'toggleNotes';
    const icon = document.createElement('i');
    icon.className = 'material-icons';
    icon.textContent = 'note_add';
    notesButton.appendChild(icon);
    document.querySelector('.fab-menu').appendChild(notesButton);

    notesButton.addEventListener('click', () => {
        toggleNotesOverlay();
        document.querySelector('.fab-menu').style.display = 'none';
    });
}

function insertTextAtCursor(element, text) {
    // Focus the element first
    element.focus();

    // Try to get current selection or create a new one at the end
    let range;
    try {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            range = selection.getRangeAt(0);
        } else {
            range = document.createRange();
            range.selectNodeContents(element);
            range.collapse(false); // Collapse to end
            selection.removeAllRanges();
            selection.addRange(range);
        }
    } catch(e) {
        // If selection fails, append to the end
        element.innerHTML += text;
        return;
    }

    try {
        // Create temporary div to hold HTML content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        
        // Insert the HTML content
        range.deleteContents();
        while (tempDiv.firstChild) {
            range.insertNode(tempDiv.firstChild);
        }
        
        // Move cursor to end of inserted text
        range.collapse(false);
    } catch(e) {
        // If insertion fails, append to the end
        element.innerHTML += text;
    }

    // Update notes content
    notes = element.innerHTML;
}



// Reference dot management
function addReferenceDot(cell, color = dotColors[currentColorIndex]) {
    let dot = cell.querySelector('.reference-dot');
    if (!dot) {
        dot = document.createElement('div');
        dot.className = 'reference-dot';
        cell.appendChild(dot);
    }
    dot.style.backgroundColor = color;
    dot.style.display = 'block';
}

function clearReferenceDots() {
    referencedCells.clear();
    document.querySelectorAll('.reference-dot').forEach(dot => {
        dot.style.display = 'none';
    });
}

function updateReferenceDots() {
    document.querySelectorAll('.reference-dot').forEach(dot => {
        dot.style.display = isNotepadOpen ? 'block' : 'none';
    });
}

        function createGrid() {
            grid.innerHTML = ''
            grid.style.width = `${totalGridSize}px`
            grid.style.height = `${totalGridSize}px`
            mapData = Array(gridSize)
                .fill()
                .map(() => Array(gridSize).fill(null))

            // Set initial view to top-left corner
            translateX = 0
            translateY = 0
            scale = 1

            updateGridTransform()
        }

        // Add this function to generate column labels
        function getColumnLabel(col) {
    const baseChar = Math.floor(col / 4);
    const subIndex = col % 4;
    if (subIndex === 0) {
        return String.fromCharCode(65 + baseChar); // A, B, C, ...
    } else {
        return `${String.fromCharCode(65 + baseChar)}${subIndex}`; // A1, A2, A3, B1, B2, B3...
    }
}

        function isValidGridPosition(row, col) {
    return row >= 0 && row < gridSize && col >= 0 && col < gridSize;
}

function parseCoordinatesFromNotes(notesText) {
    // Match patterns like [A1], [B12], [AA34], etc.
    const coordPattern = /\[([A-Z]{1,2}\d+)\]/g;
    const matches = new Set();
    let match;

    while ((match = coordPattern.exec(notesText)) !== null) {
        matches.add(match[1]); // Store the coordinate without brackets
    }

    return matches;
}

// Convert coordinate format to row-col format
function coordinateToRowCol(coord) {
    const letterPart = coord.match(/[A-Z]+/)[0];
    const numberPart = parseInt(coord.match(/\d+/)[0]);

    let col = 0;
    // Calculate base column (A=0, B=4, C=8, etc.)
    const baseCol = (letterPart.charCodeAt(0) - 'A'.charCodeAt(0)) * 4;
    
    // Add subindex if it exists (A1=1, A2=2, A3=3, B1=5, etc.)
    const subIndex = coord.match(/\d+$/);
    col = baseCol + (subIndex ? parseInt(subIndex[0]) : 0);

    return {
        row: numberPart,
        col: col
    };
}

function restoreReferenceDots() {
    // Clear existing dots first
    clearReferenceDots();
    
    // Create a set to store all cell references
    const allReferences = new Set();

    // Add references from saved referencedCells
    referencedCells.forEach(ref => {
        allReferences.add({
            cellId: typeof ref === 'string' ? ref : ref.cellId,
            color: typeof ref === 'string' ? dotColors[0] : ref.color
        });
    });

    // Parse coordinates and colors from notes text
    const coordMatches = [...notes.matchAll(/\<span style="color: ([^"]+)"\>\[([A-Z]{1,2}\d+)\]\<\/span\>/g)];
    coordMatches.forEach(match => {
        const [_, color, coord] = match;
        const { row, col } = coordinateToRowCol(coord);
        allReferences.add({
            cellId: `${row}-${col}`,
            color: color
        });
    });

    // Apply dots to all referenced cells
    allReferences.forEach(({cellId, color}) => {
        const [row, col] = cellId.split('-').map(Number);
        const cell = getCell(row, col);
        if (cell) {
            addReferenceDot(cell, color);
            referencedCells.add({cellId, color});
        }
    });

    // Only show dots if notepad is open
    updateReferenceDots();
}

// Enhanced grid cell management
function createCell(row, col) {
    if (!isValidGridPosition(row, col)) {
        console.log('Attempted to create cell outside grid bounds:', { row, col });
        return null;
    }

    const cellId = `${row}-${col}`;
    let cell = cells.get(cellId);

    if (!cell) {
        cell = document.createElement('div');
        cell.classList.add('cell');
        cell.style.left = `${col * cellSize}px`;
        cell.style.top = `${row * cellSize}px`;

        if (row === 0 || col === 0) {
            cell.classList.add('coordinate-label');
            if (row === 0 && col === 0) {
                cell.textContent = '';
            } else if (row === 0) {
                cell.textContent = getColumnLabel(col - 1);
            } else {
                cell.textContent = row;
            }
        } else {
            // Restore cell state from mapData
            const cellState = mapData[row][col];
            if (cellState) {
                if (cellState === 'filled') {
                    cell.classList.add('filled');
                } else if (cellState.startsWith('diagonalPath')) {
                    // Restore diagonal state
                    const direction = cellState.replace('diagonalPath', '').toLowerCase();
                    cell.classList.add(`diagonal-${direction}`);
                } else {
                    // Restore special elements (doors, enemies, etc.)
                    cell.classList.add('filled');
                    restoreMapElement(cell, row, col, cellState);
                }
            }

            cell.addEventListener('click', (e) => {
                e.preventDefault();
                handleCellClick(cell, row, col);
            });
        }

        grid.appendChild(cell);
        cells.set(cellId, cell);

        // Update connections after state restoration
        if (cell.classList.contains('filled') || 
            cell.classList.contains('diagonal-ne') || 
            cell.classList.contains('diagonal-se') || 
            cell.classList.contains('diagonal-sw') || 
            cell.classList.contains('diagonal-nw')) {
            updateBorders(cell, row, col);
        }
    }
    return cell;
}

// Helper function to restore map elements
async function restoreMapElement(cell, row, col, elementType) {
    const icons = getIconClass(elementType);
    const isRpgIconAvailable = await checkIconAvailability(icons.ra);

    if (elementType === 'secretdoor' || elementType === 'trap') {
        cell.classList.add('secret-element');
        const secretContainer = document.createElement('div');
        secretContainer.className = 'secret-container';

        const iconElement = document.createElement('i');
        if (isRpgIconAvailable) {
            iconElement.className = `ra ${icons.ra}`;
        } else {
            iconElement.className = 'material-icons';
            iconElement.textContent = icons.material;
        }

        secretContainer.appendChild(iconElement);
        cell.appendChild(secretContainer);
    } else {
        const iconElement = document.createElement('i');
        if (isRpgIconAvailable) {
            iconElement.className = `ra ${icons.ra}`;
        } else {
            iconElement.className = 'material-icons';
            iconElement.textContent = icons.material;
        }
        cell.appendChild(iconElement);
    }
}

// Update the visibility checking to preserve more cells
function updateVisibleCells() {
    // Increase buffer for better state preservation
    const bufferCells = 5;
    
    const visibleStartCol = Math.max(
        0,
        Math.floor(-translateX / cellSize) - bufferCells
    );
    const visibleStartRow = Math.max(
        0,
        Math.floor(-translateY / cellSize) - bufferCells
    );
    const visibleEndCol = Math.min(
        gridSize,
        Math.ceil((-translateX + window.innerWidth / scale) / cellSize) + bufferCells
    );
    const visibleEndRow = Math.min(
        gridSize,
        Math.ceil((-translateY + window.innerHeight / scale) / cellSize) + bufferCells
    );

    // Track visible cells
    const visibleCellIds = new Set();

    // Create or update visible cells
    for (let row = visibleStartRow; row < visibleEndRow; row++) {
        for (let col = visibleStartCol; col < visibleEndCol; col++) {
            if (isValidGridPosition(row, col)) {
                const cell = createCell(row, col);
                if (cell) {
                    const cellId = `${row}-${col}`;
                    visibleCellIds.add(cellId);
                }
            }
        }
    }

    // Only remove cells that are well outside the visible area
    for (const [cellId, cell] of cells) {
        if (!visibleCellIds.has(cellId)) {
            const [row, col] = cellId.split('-').map(Number);
            // Check if cell is far outside visible area before removing
            const isFarOutside = 
                row < visibleStartRow - bufferCells ||
                row >= visibleEndRow + bufferCells ||
                col < visibleStartCol - bufferCells ||
                col >= visibleEndCol + bufferCells;
            
            if (isFarOutside) {
                grid.removeChild(cell);
                cells.delete(cellId);
            }
        }
    }

    if (isNotepadOpen) {
        restoreReferenceDots();
    }
}

// Helper function to check if a cell is visible
function isCellVisible(row, col) {
    const cell = getCell(row, col);
    if (!cell) return false;

    const rect = cell.getBoundingClientRect();
    return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= window.innerHeight &&
        rect.right <= window.innerWidth
    );
}

        function createCoordinateLabels() {
            const rowLabels = document.getElementById('row-labels')
            const colLabels = document.getElementById('col-labels')

            for (let i = 0; i < gridSize; i++) {
                const rowLabel = document.createElement('div')
                rowLabel.className = 'grid-label'
                rowLabel.style.left = '0'
                rowLabel.style.top = `${i * cellSize + 20}px`
                rowLabel.style.width = '20px'
                rowLabel.style.height = `${cellSize}px`
                rowLabel.textContent = (i + 1).toString()
                rowLabels.appendChild(rowLabel)

                const colLabel = document.createElement('div')
                colLabel.className = 'grid-label'
                colLabel.style.top = '0'
                colLabel.style.left = `${i * cellSize + 20}px`
                colLabel.style.width = `${cellSize}px`
                colLabel.style.height = '20px'
                colLabel.textContent = String.fromCharCode(65 + i) // A, B, C, ...
                colLabels.appendChild(colLabel)
            }
        }

        function updateCoordinateLabels() {
            const rowLabels = document.getElementById('row-labels')
            const colLabels = document.getElementById('col-labels')

            rowLabels.style.transform = `translateY(${translateY}px) scale(${scale})`
            colLabels.style.transform = `translateX(${translateX}px) scale(${scale})`
        }

// Enhanced boundary-aware transform handling
function validateTransformBounds(newTranslateX, newTranslateY, currentScale) {
    const maxTranslate = totalGridSize;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    // Calculate the minimum translation needed to keep the grid visible
    const minTranslateX = -maxTranslate + (viewportWidth / currentScale);
    const minTranslateY = -maxTranslate + (viewportHeight / currentScale);

    // Clamp values within bounds
    return {
        translateX: Math.min(maxTranslate / 4, Math.max(minTranslateX, newTranslateX)),
        translateY: Math.min(maxTranslate / 4, Math.max(minTranslateY, newTranslateY))
    };
}

// Update the updateGridTransform function
function updateGridTransform() {
    // Store current state
    const currentState = {
        translateX,
        translateY,
        scale
    };

    // Validate bounds
    const validated = validateTransformBounds(translateX, translateY, scale);
    translateX = validated.translateX;
    translateY = validated.translateY;

    requestAnimationFrame(() => {
        // Use matrix for transform
        const matrix = `matrix(${scale}, 0, 0, ${scale}, ${translateX}, ${translateY})`;
        grid.style.transform = matrix;

        // Ensure the transform values haven't changed unexpectedly
        if (translateX !== currentState.translateX || 
            translateY !== currentState.translateY || 
            scale !== currentState.scale) {
            console.log('Transform values changed unexpectedly, restoring');
            translateX = currentState.translateX;
            translateY = currentState.translateY;
            scale = currentState.scale;
            grid.style.transform = `matrix(${scale}, 0, 0, ${scale}, ${translateX}, ${translateY})`;
        }

        // Update visible cells after transform is complete
        updateVisibleCells();
    });
}




function validateTransformState() {
    const maxTranslate = totalGridSize * scale;
    const minTranslate = -maxTranslate;

    // Clamp translate values within bounds
    translateX = Math.max(minTranslate, Math.min(maxTranslate, translateX));
    translateY = Math.max(minTranslate, Math.min(maxTranslate, translateY));

    // Clamp scale within reasonable bounds
    scale = Math.max(0.5, Math.min(3, scale));

    return {
        translateX,
        translateY,
        scale
    };
}

        function screenToGridCoordinates(screenX, screenY) {
            const rect = gridContainer.getBoundingClientRect()
            const gridX = (screenX - rect.left - 20) / scale - translateX
            const gridY = (screenY - rect.top - 20) / scale - translateY

            const col = Math.floor(gridX / cellSize)
            const row = Math.floor(gridY / cellSize)

            return { row, col }
        }

        function updateDiagonalModeIndicator() {
            const diagonalPathButton = document.getElementById('diagonalPath')
            if (diagonalPathButton) {
                diagonalPathButton.style.backgroundColor = isDiagonalModeActive
                    ? '#4CAF50'
                    : '#1E88E5'
            }

            document
                .querySelectorAll('#diagonalPathSubmenu .fab-item')
                .forEach(item => {
                    const isActive =
                        isDiagonalModeActive &&
                        item.id.toLowerCase() === activeDiagonalDirection.toLowerCase()
                    item.style.backgroundColor = isActive ? '#4CAF50' : '#1E88E5'
                })
        }

        function handleDiagonalAtBoundary(cell, row, col, direction) {
    if (!isValidGridPosition(row, col)) return;

    // Check if this would create an invalid diagonal at the grid edge
    const isEdgeCell = row === 0 || col === 0 || row === gridSize - 1 || col === gridSize - 1;
    if (isEdgeCell) {
        // Add specific handling for edge diagonals
        const edgeClasses = {
            'diagonal-ne': col === gridSize - 1 || row === 0,
            'diagonal-nw': col === 0 || row === 0,
            'diagonal-se': col === gridSize - 1 || row === gridSize - 1,
            'diagonal-sw': col === 0 || row === gridSize - 1
        };

        // Apply appropriate edge styling
        Object.entries(edgeClasses).forEach(([className, shouldApply]) => {
            if (shouldApply) {
                cell.classList.add(`${className}-edge`);
            }
        });
    }
}

        function handleCellClick(cell, row, col) {
    // Store current transform state
    const currentState = {
        translateX,
        translateY,
        scale
    };

    // Prevent default behavior that might cause shifts
    event.preventDefault();
    event.stopPropagation();

    console.log('Cell clicked:', {
        row,
        col,
        currentMode,
        activeElementType,
        isDiagonalModeActive,
        isElementModeActive,
        transform: currentState
    });

    if (row === 0 || col === 0) return;

    // Handle the click based on current mode
    if (isDiagonalModeActive && activeDiagonalDirection) {
        toggleDiagonalPath(cell, row, col, activeDiagonalDirection);
    } else if (isElementModeActive && activeElementType) {
        if (cell.classList.contains('filled') ||
            cell.classList.contains('diagonal-ne') ||
            cell.classList.contains('diagonal-se') ||
            cell.classList.contains('diagonal-sw') ||
            cell.classList.contains('diagonal-nw')) {
            addMapElement(cell, row, col, activeElementType);
        }
    } else {
        const normalizedMode = currentMode.replace(/^(add|mark)/, '').toLowerCase();
        switch (normalizedMode) {
            case 'fill':
                toggleFill(cell, row, col);
                break;
            case 'eraser':
                eraseCell(cell, row, col);
                break;
            case 'door':
            case 'secretdoor':
            case 'enemy':
            case 'stairs':
            case 'trap':
            case 'npc':
            case 'treasure':
                if (cell.classList.contains('filled') ||
                    cell.classList.contains('diagonal-ne') ||
                    cell.classList.contains('diagonal-se') ||
                    cell.classList.contains('diagonal-sw') ||
                    cell.classList.contains('diagonal-nw')) {
                    addMapElement(cell, row, col, normalizedMode);
                }
                break;
            default:
                console.log('Unhandled mode:', normalizedMode);
                break;
        }
    }

    if (isNotepadOpen) {
        event.preventDefault();
        event.stopPropagation();

        const coords = `${getColumnLabel(col)}${row}`;
        const currentColor = dotColors[currentColorIndex];
        
        // Add colored dot to the cell
        addReferenceDot(cell, currentColor);
        
        // Create colored coordinate text with a dot
        const coloredCoord = `<span style="color: ${currentColor}">‚óè[${coords}]</span> `;
        
        // Get the notes display element and ensure it exists
        const notesDisplay = document.querySelector('.notes-display');
        if (notesDisplay) {
            // Focus the display div before inserting text
            notesDisplay.focus();
            insertTextAtCursor(notesDisplay, coloredCoord);
        }
        
        referencedCells.add({
            cellId: `${row}-${col}`,
            color: currentColor
        });
        return;
    }

    // Check if transform changed and restore if necessary
    if (translateX !== currentState.translateX || 
        translateY !== currentState.translateY || 
        scale !== currentState.scale) {
        console.log('Transform changed during click, restoring previous state');
        translateX = currentState.translateX;
        translateY = currentState.translateY;
        scale = currentState.scale;
        requestAnimationFrame(() => {
            updateGridTransform();
        });
    }
}

        function eraseCell(cell, row, col) {
            // Remove any icons from the cell
            cell.innerHTML = ''

            // Remove all classes except 'cell' and 'filled'
            cell.className = 'cell filled'

            // Update mapData
            mapData[row][col] = 'filled'

            // Update cell appearance
            updateBorders(cell, row, col)
        }

        function updateCellAppearance(cell, row, col) {
            // This function remains the same
            if (mapData[row] && mapData[row][col] === 'filled') {
                cell.classList.add('filled')
            } else {
                cell.classList.remove('filled')
            }
            updateBorders(cell, row, col)
        }

        function toggleFill(cell, row, col) {
    const isFilled = !cell.classList.contains('filled');
    
    if (isFilled) {
        cell.classList.add('filled');
        mapData[row][col] = 'filled';
    } else {
        cell.classList.remove('filled');
        cell.innerHTML = '';
        mapData[row][col] = null;
    }

    updateBorders(cell, row, col);
    updateNeighboringCells(row, col);
}

        function toggleDiagonalPath(cell, row, col, direction) {
    console.log('Toggling diagonal path:', { row, col, direction });

    const directionSuffix = direction.replace('diagonalPath', '').toLowerCase();
    const diagonalClass = `diagonal-${directionSuffix}`;

    // Store original position
    const originalLeft = cell.style.left;
    const originalTop = cell.style.top;

    if (cell.classList.contains(diagonalClass)) {
        // Remove diagonal path
        cell.classList.remove(
            'diagonal-ne', 'diagonal-se', 'diagonal-sw', 'diagonal-nw',
            'connected-left', 'connected-right', 'connected-top', 'connected-bottom',
            'connected-top-left', 'connected-top-right',
            'connected-bottom-left', 'connected-bottom-right'
        );
        cell.style.background = '';
        mapData[row][col] = null;

        // Update neighboring cells
        updateNeighboringCells(row, col);
    } else {
        // Clear existing content and classes but maintain position
        cell.innerHTML = '';
        cell.className = 'cell';
        cell.classList.add(diagonalClass);
        mapData[row][col] = direction;

        // Update connections
        updateDiagonalConnections(cell, row, col);
        updateNeighboringCells(row, col);
    }

    // Restore position
    cell.style.left = originalLeft;
    cell.style.top = originalTop;

    // Update borders and connections for neighbors
    updateNeighboringCells(row, col);
}

function updateNeighboringCells(row, col) {
    const neighbors = [
        { row: row - 1, col: col - 1 }, // top-left
        { row: row - 1, col: col },     // top
        { row: row - 1, col: col + 1 }, // top-right
        { row: row, col: col - 1 },     // left
        { row: row, col: col + 1 },     // right
        { row: row + 1, col: col - 1 }, // bottom-left
        { row: row + 1, col: col },     // bottom
        { row: row + 1, col: col + 1 }  // bottom-right
    ];

    neighbors.forEach(pos => {
        const cell = getCell(pos.row, pos.col);
        if (cell) {
            const diagonalType = getDiagonalType(cell);
            if (diagonalType) {
                updateDiagonalConnections(cell, pos.row, pos.col);
            } else {
                updateBorders(cell, pos.row, pos.col);
            }
        }
    });
}

        // Updated updateBorders function for diagonal handling
        function updateBorders(cell, row, col) {
            if (!cell) return

            const directions = [
                { name: 'left', condition: col > 0, neighbor: getCell(row, col - 1) },
                {
                    name: 'right',
                    condition: col < gridSize - 1,
                    neighbor: getCell(row, col + 1)
                },
                { name: 'top', condition: row > 0, neighbor: getCell(row - 1, col) },
                {
                    name: 'bottom',
                    condition: row < gridSize - 1,
                    neighbor: getCell(row + 1, col)
                }
            ]

            // Check if this cell is diagonal
            const isDiagonal =
                cell.classList.contains('diagonal-ne') ||
                cell.classList.contains('diagonal-se') ||
                cell.classList.contains('diagonal-sw') ||
                cell.classList.contains('diagonal-nw')

            // Remove all border-related classes if it's a diagonal cell
            if (isDiagonal) {
                cell.classList.remove('left', 'right', 'top', 'bottom')
                directions.forEach(dir => {
                    if (dir.condition && dir.neighbor) {
                        const isNeighborFilled =
                            dir.neighbor.classList.contains('filled') ||
                            dir.neighbor.classList.contains('diagonal-ne') ||
                            dir.neighbor.classList.contains('diagonal-se') ||
                            dir.neighbor.classList.contains('diagonal-sw') ||
                            dir.neighbor.classList.contains('diagonal-nw')

                        if (isNeighborFilled) {
                            dir.neighbor.classList.add(
                                `connected-${getOppositeDirection(dir.name)}`
                            )
                        }
                    }
                })
                return
            }

            // Handle regular cell borders
            directions.forEach(dir => {
                if (dir.condition && dir.neighbor) {
                    const isNeighborFilled =
                        dir.neighbor.classList.contains('filled') ||
                        dir.neighbor.classList.contains('diagonal-ne') ||
                        dir.neighbor.classList.contains('diagonal-se') ||
                        dir.neighbor.classList.contains('diagonal-sw') ||
                        dir.neighbor.classList.contains('diagonal-nw')

                    if (cell.classList.contains('filled') && isNeighborFilled) {
                        cell.classList.add(`connected-${dir.name}`)
                        dir.neighbor.classList.add(
                            `connected-${getOppositeDirection(dir.name)}`
                        )
                    } else {
                        cell.classList.remove(dir.name, `connected-${dir.name}`)
                        dir.neighbor.classList.remove(
                            getOppositeDirection(dir.name),
                            `connected-${getOppositeDirection(dir.name)}`
                        )
                    }
                }
            })
        }

        function getCell(row, col) {
            const cell = cells.get(`${row}-${col}`)
            if (!cell) {
                console.log('No cell found at:', { row, col })
            }
            return cell
        }

        function getOppositeDirection(direction) {
            const opposites = {
                left: 'right',
                right: 'left',
                top: 'bottom',
                bottom: 'top'
            }
            return opposites[direction]
        }

        // Icon Functions
        function checkIconAvailability(iconClass) {
            return new Promise(resolve => {
                const tempIcon = document.createElement('i')
                tempIcon.className = `ra ${iconClass}`
                tempIcon.style.position = 'absolute'
                tempIcon.style.visibility = 'hidden'
                document.body.appendChild(tempIcon)

                setTimeout(() => {
                    const isAvailable =
                        tempIcon.offsetWidth > 0 && tempIcon.offsetHeight > 0
                    document.body.removeChild(tempIcon)
                    resolve(isAvailable)
                }, 50)
            })
        }

        async function createIcon(iconObj) {
            if (iconObj.ra) {
                const isRpgIconAvailable = await checkIconAvailability(iconObj.ra)
                const icon = document.createElement('i')

                if (isRpgIconAvailable) {
                    icon.className = `ra ${iconObj.ra}`
                } else {
                    icon.className = 'material-icons'
                    icon.textContent = iconObj.material
                }

                return icon
            } else if (iconObj.material) {
                const icon = document.createElement('i')
                icon.className = 'material-icons'
                icon.textContent = iconObj.material
                return icon
            }

            return null
        }

        function getIconClass(mode) {
            console.log('Getting icon class for mode:', mode)
            const iconInfo = iconMap[mode] || { ra: '', material: '' }
            console.log('Found icon info:', iconInfo)
            return iconInfo
        }

        function getActualZIndex(element) {
            return window.getComputedStyle(element).zIndex
        }

        async function addMapElement(cell, row, col, mode) {
            console.log('addMapElement called with:', { mode, row, col })

            if (cell.classList.contains('filled')) {
                console.log('Cell is filled, proceeding with icon placement')

                // Remove any existing icons
                const existingIcon = cell.querySelector('i')
                if (existingIcon) {
                    existingIcon.remove()
                    console.log('Removed existing icon')
                }

                const icons = getIconClass(mode)
                console.log('Icon class for mode:', icons)
                const isRpgIconAvailable = await checkIconAvailability(icons.ra)
                console.log('RPG icon available:', isRpgIconAvailable)

                const iconElement = document.createElement('i')
                iconElement.style.zIndex = '100'

                if (isRpgIconAvailable) {
                    iconElement.className = `ra ${icons.ra}`
                    console.log('Using RPG icon:', icons.ra)
                } else {
                    iconElement.className = 'material-icons'
                    iconElement.textContent = icons.material
                    console.log('Using material icon:', icons.material)
                }

                // Check for diagonal cell and apply positioning
                if (cell.classList.contains('diagonal-ne')) {
                    iconElement.style.top = '25%' // Top right corner
                    iconElement.style.left = '75%'
                    iconElement.style.fontSize = '16px'
                } else if (cell.classList.contains('diagonal-se')) {
                    iconElement.style.top = '75%' // Bottom right corner
                    iconElement.style.left = '75%'
                    iconElement.style.fontSize = '16px'
                } else if (cell.classList.contains('diagonal-sw')) {
                    iconElement.style.top = '75%' // Bottom left corner
                    iconElement.style.left = '25%'
                    iconElement.style.fontSize = '16px'
                } else if (cell.classList.contains('diagonal-nw')) {
                    iconElement.style.top = '25%' // Top left corner
                    iconElement.style.left = '25%'
                    iconElement.style.fontSize = '16px'
                }

                console.log('Created icon element:', iconElement)

                if (mode === 'secretdoor' || mode === 'trap') {
                    cell.classList.add('secret-element')
                    const secretContainer = document.createElement('div')
                    secretContainer.className = 'secret-container'
                    secretContainer.style.zIndex = '100'
                    secretContainer.appendChild(iconElement)
                    cell.appendChild(secretContainer)
                    console.log('Added as secret element')

                    // Add click event to toggle reveal for secret elements
                    cell.addEventListener('click', e => {
                        e.stopPropagation()
                        cell.classList.toggle('revealed')
                    })
                } else {
                    cell.appendChild(iconElement)
                    console.log('Added as regular element')
                }

                console.log('Icon added to cell. Final cell state:', {
                    classList: cell.className,
                    iconElement: iconElement.outerHTML,
                    cellContents: cell.innerHTML
                })

                mapData[row][col] = mode
                updateBorders(cell, row, col)
            }
        }
        // FAB Menu Functions
        async function createFabMenu() {
            for (const item of menuItems) {
                const fabItem = document.createElement('div')
                fabItem.id = item.id
                console.log('Creating menu item:', item.id)
                fabItem.className = `fab-item ${item.class || ''}`

                const icon = await createIcon(item.icon)
                if (icon) {
                    fabItem.appendChild(icon)
                }

                fabMenu.appendChild(fabItem)

                if (item.submenu) {
                    const submenu = document.createElement('div')
                    submenu.className = 'fab-submenu'
                    submenu.id = `${item.id}Submenu`
                    console.log('Creating submenu:', submenu.id)

                    for (const subItem of item.submenu) {
                        const subFabItem = document.createElement('div')
                        subFabItem.id = subItem.id
                        console.log('Creating submenu item:', subItem.id)
                        subFabItem.className = 'fab-item'

                        const subIcon = await createIcon(subItem.icon)
                        if (subIcon) {
                            subFabItem.appendChild(subIcon)
                        }

                        submenu.appendChild(subFabItem)
                    }

                    fabMenu.appendChild(submenu)
                }
            }
        }

        function createDiagonalRotateFab() {
            // Remove any existing diagonal FAB first
            const existingFab = document.getElementById('diagonalRotateFab')
            if (existingFab) {
                existingFab.remove()
            }

            const rotateFab = document.createElement('div')
            rotateFab.className = 'diagonal-rotate-fab'
            rotateFab.id = 'diagonalRotateFab'

            const icon = document.createElement('i')
            icon.className = 'material-icons'
            icon.textContent = 'north_east' // Initial direction

            rotateFab.appendChild(icon)
            document.body.appendChild(rotateFab)

            // Add these styles if not already in your CSS
            rotateFab.style.position = 'fixed'
            rotateFab.style.bottom = '20px'
            rotateFab.style.right = '90px'
            rotateFab.style.width = '40px'
            rotateFab.style.height = '40px'
            rotateFab.style.borderRadius = '50%'
            rotateFab.style.backgroundColor = '#1E88E5'
            rotateFab.style.color = 'white'
            rotateFab.style.display = 'none'
            rotateFab.style.justifyContent = 'center'
            rotateFab.style.alignItems = 'center'
            rotateFab.style.cursor = 'pointer'
            rotateFab.style.boxShadow = '0 2px 5px rgba(0,0,0,0.3)'
            rotateFab.style.zIndex = '1000'

            icon.style.fontSize = '20px'

            return rotateFab
        }

        // Add function to cycle through diagonal directions
        function cycleDiagonalDirection() {
            currentDiagonalIndex =
                (currentDiagonalIndex + 1) % diagonalDirections.length
            const direction = diagonalDirections[currentDiagonalIndex]
            activeDiagonalDirection = `diagonalPath${direction}`

            // Update the icon based on direction
            const icon = document.querySelector('#diagonalRotateFab i')
            switch (direction) {
                case 'NE':
                    icon.textContent = 'north_east'
                    break
                case 'SE':
                    icon.textContent = 'south_east'
                    break
                case 'SW':
                    icon.textContent = 'south_west'
                    break
                case 'NW':
                    icon.textContent = 'north_west'
                    break
            }

            console.log('Diagonal direction changed to:', activeDiagonalDirection)
        }

        function createElementsRotateFab() {
            // Remove any existing elements FAB first
            const existingFab = document.getElementById('elementsRotateFab')
            if (existingFab) {
                existingFab.remove()
            }

            const rotateFab = document.createElement('div')
            rotateFab.className = 'elements-rotate-fab'
            rotateFab.id = 'elementsRotateFab'

            const icon = document.createElement('i')
            icon.className = 'material-icons'
            icon.textContent = 'door_front' // Initial icon

            rotateFab.appendChild(icon)
            document.body.appendChild(rotateFab)

            return rotateFab
        }

        async function cycleElementType(e) {
            if (e) e.stopPropagation()

            currentElementIndex = (currentElementIndex + 1) % elementTypes.length
            activeElementType = elementTypes[currentElementIndex]

            const icon = document.querySelector('#elementsRotateFab i')
            if (icon) {
                const icons = getIconClass(activeElementType)
                console.log('Setting icon for element:', activeElementType, icons)

                const isRpgIconAvailable = await checkIconAvailability(icons.ra)

                if (isRpgIconAvailable) {
                    icon.className = `ra ${icons.ra}`
                    icon.textContent = ''
                    console.log('Using RPG icon:', icons.ra)
                } else {
                    icon.className = 'material-icons'
                    icon.textContent = icons.material
                    console.log('Using material icon:', icons.material)
                }
            }

            console.log('Element type changed to:', activeElementType)
        }

        async function createLegend() {
    const legendContentDiv = document.getElementById('legendContent');
    
    // Simply use the predefined legendContent
    legendContentDiv.innerHTML = legendContent;
    
    // No need for the old item-by-item creation since 
    // the new content includes everything in the template string
}

function setupLegend() {
    // Just call createLegend to set up initial content
    createLegend();
}

        function handlePan(dx, dy) {
    // Store current state
    const currentState = {
        translateX,
        translateY,
        scale
    };

    // Calculate new positions
    const newTranslateX = translateX + dx / scale;
    const newTranslateY = translateY + dy / scale;

    // Validate new positions
    const validated = validateTransformBounds(newTranslateX, newTranslateY, scale);
    
    if (validated.translateX !== translateX || validated.translateY !== translateY) {
        translateX = validated.translateX;
        translateY = validated.translateY;
        
        requestAnimationFrame(() => {
            updateGridTransform();
            
            // Verify transform didn't cause unexpected changes
            if (translateX !== validated.translateX || translateY !== validated.translateY) {
                console.log('Correcting unexpected transform change during pan');
                translateX = currentState.translateX;
                translateY = currentState.translateY;
                updateGridTransform();
            }
        });
    }
}

function updateDiagonalConnections(cell, row, col) {
    const diagonalType = getDiagonalType(cell);
    if (!diagonalType) return;

    // Clear existing connection classes
    cell.classList.remove(
        'connected-left', 'connected-right',
        'connected-top', 'connected-bottom'
    );

    // Get neighboring cells
    const neighbors = {
        top: row > 0 ? getCell(row - 1, col) : null,
        bottom: row < gridSize - 1 ? getCell(row + 1, col) : null,
        left: col > 0 ? getCell(row, col - 1) : null,
        right: col < gridSize - 1 ? getCell(row, col + 1) : null,
        topLeft: row > 0 && col > 0 ? getCell(row - 1, col - 1) : null,
        topRight: row > 0 && col < gridSize - 1 ? getCell(row - 1, col + 1) : null,
        bottomLeft: row < gridSize - 1 && col > 0 ? getCell(row + 1, col - 1) : null,
        bottomRight: row < gridSize - 1 && col < gridSize - 1 ? getCell(row + 1, col + 1) : null
    };

    // Check and apply connections based on diagonal type
    switch (diagonalType) {
        case 'ne':
            handleNorthEastConnections(cell, neighbors);
            break;
        case 'se':
            handleSouthEastConnections(cell, neighbors);
            break;
        case 'sw':
            handleSouthWestConnections(cell, neighbors);
            break;
        case 'nw':
            handleNorthWestConnections(cell, neighbors);
            break;
    }
}

function handleNorthEastConnections(cell, neighbors) {
    const { top, right, topRight } = neighbors;
    
    // Connect to walls and other diagonals
    if (right && (right.classList.contains('filled') || 
        right.classList.contains('diagonal-ne') || 
        right.classList.contains('diagonal-se'))) {
        cell.classList.add('connected-right');
    }
    
    if (top && (top.classList.contains('filled') || 
        top.classList.contains('diagonal-ne') || 
        top.classList.contains('diagonal-nw'))) {
        cell.classList.add('connected-top');
    }

    // Special case for diagonal-to-diagonal connections
    if (topRight && topRight.classList.contains('diagonal-se')) {
        cell.classList.add('connected-top-right');
    }
}

function handleSouthEastConnections(cell, neighbors) {
    const { bottom, right, bottomRight } = neighbors;
    
    if (right && (right.classList.contains('filled') || 
        right.classList.contains('diagonal-ne') || 
        right.classList.contains('diagonal-se'))) {
        cell.classList.add('connected-right');
    }
    
    if (bottom && (bottom.classList.contains('filled') || 
        bottom.classList.contains('diagonal-se') || 
        bottom.classList.contains('diagonal-sw'))) {
        cell.classList.add('connected-bottom');
    }

    if (bottomRight && bottomRight.classList.contains('diagonal-ne')) {
        cell.classList.add('connected-bottom-right');
    }
}

function handleSouthWestConnections(cell, neighbors) {
    const { bottom, left, bottomLeft } = neighbors;
    
    if (left && (left.classList.contains('filled') || 
        left.classList.contains('diagonal-sw') || 
        left.classList.contains('diagonal-nw'))) {
        cell.classList.add('connected-left');
    }
    
    if (bottom && (bottom.classList.contains('filled') || 
        bottom.classList.contains('diagonal-se') || 
        bottom.classList.contains('diagonal-sw'))) {
        cell.classList.add('connected-bottom');
    }

    if (bottomLeft && bottomLeft.classList.contains('diagonal-nw')) {
        cell.classList.add('connected-bottom-left');
    }
}

function handleNorthWestConnections(cell, neighbors) {
    const { top, left, topLeft } = neighbors;
    
    if (left && (left.classList.contains('filled') || 
        left.classList.contains('diagonal-sw') || 
        left.classList.contains('diagonal-nw'))) {
        cell.classList.add('connected-left');
    }
    
    if (top && (top.classList.contains('filled') || 
        top.classList.contains('diagonal-ne') || 
        top.classList.contains('diagonal-nw'))) {
        cell.classList.add('connected-top');
    }

    if (topLeft && topLeft.classList.contains('diagonal-sw')) {
        cell.classList.add('connected-top-left');
    }
}

function getDiagonalType(cell) {
    if (cell.classList.contains('diagonal-ne')) return 'ne';
    if (cell.classList.contains('diagonal-se')) return 'se';
    if (cell.classList.contains('diagonal-sw')) return 'sw';
    if (cell.classList.contains('diagonal-nw')) return 'nw';
    return null;
}

function initializePanControls() {
    // Prevent default middle-click scroll behavior
    gridContainer.addEventListener('mousedown', e => {
        if (e.button === 1) { // Middle mouse button
            e.preventDefault();
            isMiddleMouseDown = true;
            lastMiddleX = e.clientX;
            lastMiddleY = e.clientY;
            gridContainer.style.cursor = 'grabbing';
        } else if (e.button === 0) { // Left mouse button
            const rect = gridContainer.getBoundingClientRect();
            lastX = e.clientX - rect.left - 20;
            lastY = e.clientY - rect.top - 20;
        }
    });

    // Handle middle-mouse panning
    gridContainer.addEventListener('mousemove', e => {
        if (isMiddleMouseDown) {
            e.preventDefault();
            const dx = e.clientX - lastMiddleX;
            const dy = e.clientY - lastMiddleY;
            
            // Store current transform state
            const currentState = {
                translateX,
                translateY,
                scale
            };

            // Calculate new positions with bounds checking
            const newTranslateX = translateX + dx / scale;
            const newTranslateY = translateY + dy / scale;

            // Check boundaries
            const maxTranslate = totalGridSize * scale;
            if (Math.abs(newTranslateX) <= maxTranslate && 
                Math.abs(newTranslateY) <= maxTranslate) {
                translateX = newTranslateX;
                translateY = newTranslateY;
            }

            lastMiddleX = e.clientX;
            lastMiddleY = e.clientY;

            // Use requestAnimationFrame for smooth updates
            requestAnimationFrame(() => {
                updateGridTransform();
                
                // Verify transform didn't cause unexpected changes
                if (translateX !== newTranslateX || translateY !== newTranslateY) {
                    console.log('Correcting unexpected transform change during middle-mouse pan');
                    translateX = currentState.translateX;
                    translateY = currentState.translateY;
                    updateGridTransform();
                }
            });
        }
    });

    // Clear middle-mouse state
    document.addEventListener('mouseup', e => {
        if (e.button === 1) {
            isMiddleMouseDown = false;
            gridContainer.style.cursor = 'default';
        }
    });

    // Prevent context menu on middle-click
    gridContainer.addEventListener('contextmenu', e => {
        if (isMiddleMouseDown) {
            e.preventDefault();
        }
    });

    // Handle mouse leaving window
    window.addEventListener('mouseout', e => {
        if (e.relatedTarget === null) { // Mouse left the window
            isMiddleMouseDown = false;
            gridContainer.style.cursor = 'default';
        }
    });

    // Enhance existing pan handling
    let panAnimationFrame = null;
    
    function smoothPan(dx, dy) {
        // Cancel any existing animation frame
        if (panAnimationFrame) {
            cancelAnimationFrame(panAnimationFrame);
        }

        // Store current state
        const currentState = {
            translateX,
            translateY,
            scale
        };

        // Calculate new positions
        const newTranslateX = translateX + dx / scale;
        const newTranslateY = translateY + dy / scale;

        // Check boundaries
        const maxTranslate = totalGridSize * scale;
        if (Math.abs(newTranslateX) <= maxTranslate && 
            Math.abs(newTranslateY) <= maxTranslate) {
            translateX = newTranslateX;
            translateY = newTranslateY;

            panAnimationFrame = requestAnimationFrame(() => {
                updateGridTransform();
                
                // Verify transform didn't cause unexpected changes
                if (translateX !== newTranslateX || translateY !== newTranslateY) {
                    console.log('Correcting unexpected transform change during pan');
                    translateX = currentState.translateX;
                    translateY = currentState.translateY;
                    updateGridTransform();
                }
            });
        }
    }

    // Update existing mousemove handler to use smooth pan
    gridContainer.addEventListener('mousemove', e => {
    if (isMiddleMouseDown) {
        e.preventDefault();
        const dx = e.clientX - lastMiddleX;
        const dy = e.clientY - lastMiddleY;
        
        handleMiddleMousePan(dx, dy);
        
        lastMiddleX = e.clientX;
        lastMiddleY = e.clientY;
    }
});

    // Update existing touch handlers
    gridContainer.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 1 && isDragging) {
            const dx = e.touches[0].clientX - lastX;
            const dy = e.touches[0].clientY - lastY;
            
            smoothPan(dx, dy);
            
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        }
    });
}


        function setupEventListeners() {
            const fabMenuItems = document.querySelectorAll('.fab-item')

            // Ensure diagonal FAB exists
            let diagonalRotateFab = document.getElementById('diagonalRotateFab')
            let elementsRotateFab = document.getElementById('elementsRotateFab')

            if (!diagonalRotateFab) {
                diagonalRotateFab = createDiagonalRotateFab()
            }
            if (!elementsRotateFab) {
                elementsRotateFab = createElementsRotateFab()
            }

            // Main FAB button click
            fabBtn.addEventListener('click', () => {
                console.log('FAB button clicked')
                fabMenu.style.display =
                    fabMenu.style.display === 'none' ? 'flex' : 'none'
            })

            // Map Elements submenu handlers
            document
                .querySelectorAll('#mapElementsSubmenu .fab-item')
                .forEach(item => {
                    item.addEventListener('click', e => {
                        e.stopPropagation()
                        console.log(
                            'Map element submenu item clicked:',
                            e.currentTarget.id
                        )
                        const newMode = e.currentTarget.id
                            .replace(/^(add|mark)/, '')
                            .toLowerCase()
                        console.log('Setting currentMode to:', newMode)
                        currentMode = newMode

                        // Hide submenus
                        document.querySelectorAll('.fab-submenu').forEach(sub => {
                            sub.style.display = 'none'
                        })
                        fabMenu.style.display = 'none'
                    })
                })

            // Update the mapElements section in the main menu items click handler
            fabMenuItems.forEach(item => {
                item.addEventListener('click', e => {
                    const mode = e.currentTarget.id
                    console.log('FAB menu item clicked:', mode)

                    if (mode === 'toggleLegend') {
            e.stopPropagation(); // Prevent event bubbling
            const legend = document.getElementById('legend');
            const legendContentDiv = document.getElementById('legendContent');
            
            // Set content only if it's not already set
            if (!legendContentDiv.innerHTML) {
                legendContentDiv.innerHTML = legendContent;
            }
            
            // Toggle visibility
            const isCurrentlyHidden = legend.style.display === 'none' || !legend.style.display;
            legend.style.display = isCurrentlyHidden ? 'block' : 'none';
            
            console.log('Legend visibility:', legend.style.display);
            
            // Hide fab menu
            fabMenu.style.display = 'none';
            return; // Exit early to prevent other handlers
        }

                    if (mode === 'mapElements') {
                        isElementModeActive = !isElementModeActive

                        if (isElementModeActive) {
                            elementsRotateFab.style.display = 'flex'
                            // Set initial element type
                            activeElementType = elementTypes[currentElementIndex]
                            currentMode = 'element' // Use a specific mode for element placement
                            updateElementRotateFabIcon(activeElementType)
                            e.currentTarget.style.backgroundColor = '#4CAF50'
                            console.log('Element mode activated:', activeElementType)
                        } else {
                            elementsRotateFab.style.display = 'none'
                            e.currentTarget.style.backgroundColor = '#1E88E5'
                            currentMode = 'fill'
                            activeElementType = null
                            console.log('Element mode deactivated')
                        }
                        fabMenu.style.display = 'none'
                    } else if (mode === 'diagonalPath') {
                        // Rest of diagonal handling remains the same
                        isDiagonalModeActive = !isDiagonalModeActive

                        if (isDiagonalModeActive) {
                            diagonalRotateFab.style.display = 'flex'
                            currentDiagonalIndex = 0
                            activeDiagonalDirection = `diagonalPath${diagonalDirections[0]}`
                            e.currentTarget.style.backgroundColor = '#4CAF50'
                            currentMode = 'diagonal'

                            const rotateIcon = diagonalRotateFab.querySelector('i')
                            if (rotateIcon) {
                                rotateIcon.textContent = 'north_east'
                            }
                        } else {
                            diagonalRotateFab.style.display = 'none'
                            e.currentTarget.style.backgroundColor = '#1E88E5'
                            activeDiagonalDirection = ''
                            currentMode = 'fill'
                        }
                        fabMenu.style.display = 'none' // Hide menu only after handling diagonal
                    } else {
                        // Handle other menu items (eraser, save, load)
                        isDiagonalModeActive = false
                        if (diagonalRotateFab) {
                            diagonalRotateFab.style.display = 'none'
                        }
                        const diagonalBtn = document.getElementById('diagonalPath')
                        if (diagonalBtn) {
                            diagonalBtn.style.backgroundColor = '#1E88E5'
                        }

                        switch (mode) {
                            case 'eraser':
                                currentMode = 'eraser'
                                break
                            case 'saveMap':
                                saveMap()
                                break
                            case 'loadMap':
                                loadMap()
                                break
                            default:
                                currentMode = mode.replace(/^(add|mark)/, '').toLowerCase()
                        }
                        fabMenu.style.display = 'none' // Hide menu only after handling other items
                    }
                })
            })

            //legend click handler
            

            // Add click handler to diagonal rotate FAB
            diagonalRotateFab.addEventListener('click', cycleDiagonalDirection)
            elementsRotateFab.addEventListener('click', cycleElementType)

            // Close menus when clicking outside
            document.addEventListener('click', e => {
                if (
                    !fabBtn.contains(e.target) &&
                    !fabMenu.contains(e.target) &&
                    !diagonalRotateFab.contains(e.target)
                ) {
                    fabMenu.style.display = 'none'
                    document.querySelectorAll('.fab-submenu').forEach(sub => {
                        sub.style.display = 'none'
                    })
                }
            })
        }

        async function updateElementRotateFabIcon(elementType) {
            const icon = document.querySelector('#elementsRotateFab i')
            if (icon) {
                const icons = getIconClass(elementType)
                console.log('Setting icon for element:', elementType, icons)

                const isRpgIconAvailable = await checkIconAvailability(icons.ra)

                if (isRpgIconAvailable) {
                    icon.className = `ra ${icons.ra}`
                    icon.textContent = ''
                    console.log('Using RPG icon:', icons.ra)
                } else {
                    icon.className = 'material-icons'
                    icon.textContent = icons.material
                    console.log('Using material icon:', icons.material)
                }
            }
        }

        function cycleDiagonalDirection(e) {
            if (e) e.stopPropagation()

            currentDiagonalIndex =
                (currentDiagonalIndex + 1) % diagonalDirections.length
            const direction = diagonalDirections[currentDiagonalIndex]
            activeDiagonalDirection = `diagonalPath${direction}`

            const icon = document.querySelector('#diagonalRotateFab i')
            if (icon) {
                switch (direction) {
                    case 'NE':
                        icon.textContent = 'north_east'
                        break
                    case 'SE':
                        icon.textContent = 'south_east'
                        break
                    case 'SW':
                        icon.textContent = 'south_west'
                        break
                    case 'NW':
                        icon.textContent = 'north_west'
                        break
                }
            }

            console.log('Diagonal direction changed to:', activeDiagonalDirection)
        }

        // Save and Load Functions
        function saveMap() {
    const filledCells = [];
    const specialCells = [];

    cells.forEach((cell, key) => {
        const [row, col] = key.split('-').map(Number);
        if (cell.classList.contains('filled')) {
            filledCells.push({ row, col });

            // Check for diagonal paths
            const diagonalDirections = ['ne', 'se', 'sw', 'nw'];
            const diagonalDirection = diagonalDirections.find(dir =>
                cell.classList.contains(`diagonal-${dir}`)
            );

            if (diagonalDirection) {
                specialCells.push({
                    row,
                    col,
                    type: 'diagonal',
                    direction: diagonalDirection
                });
            } else {
                const iconElement = cell.querySelector('i');
                if (iconElement) {
                    const type = getElementTypeFromIcon(iconElement);
                    specialCells.push({
                        row,
                        col,
                        type,
                        isSecret: cell.classList.contains('secret-element'),
                        isRevealed: cell.classList.contains('revealed')
                    });
                }
            }
        }
    });

    // Get notes content from displayDiv
    const notesContent = document.querySelector('.notes-display')?.innerHTML || notes;

    const saveData = {
        filledCells,
        specialCells,
        notes: notesContent,
        referencedCells: Array.from(referencedCells).map(ref => ({
            cellId: typeof ref === 'string' ? ref : ref.cellId,
            color: typeof ref === 'string' ? dotColors[0] : ref.color
        }))
    };

    const mapJson = JSON.stringify(saveData);
    const blob = new Blob([mapJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const filename = 'TapMap_' + new Date().toJSON().slice(0, 10) + '.json';
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

        function getElementTypeFromIcon(iconElement) {
            if (iconElement.classList.contains('ra')) {
                return Object.keys(iconMap).find(key =>
                    iconElement.classList.contains(iconMap[key].ra)
                )
            } else if (iconElement.classList.contains('material-icons')) {
                return Object.keys(iconMap).find(
                    key => iconElement.textContent === iconMap[key].material
                )
            }
            return null
        }

        // Updated loadMap function
        async function loadMap() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'application/json';
    input.onchange = event => {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = e => {
            const loadedData = JSON.parse(e.target.result);
            
            // Load notes and referenced cells
            notes = loadedData.notes || '';
            
            // Handle both old and new format of referencedCells
            if (Array.isArray(loadedData.referencedCells)) {
                // Old format - convert to new format
                referencedCells = new Set(loadedData.referencedCells.map(cellId => ({
                    cellId,
                    color: dotColors[0] // Default to first color for old format
                })));
            } else {
                // New format with colors
                referencedCells = new Set(loadedData.referencedCells || []);
            }

            // Update notes display
            const displayDiv = document.querySelector('.notes-display');
            if (displayDiv) {
                displayDiv.innerHTML = notes;
            }

            // Render the map first
            renderLoadedMap(loadedData);

            // Then restore reference dots
            setTimeout(() => {
                restoreReferenceDots();
            }, 100); // Small delay to ensure cells are rendered
        };
        reader.readAsText(file);
    };
    input.click();
}

        // Updated renderLoadedMap function
        async function renderLoadedMap(loadedData) {
            // Clear all existing cells
            cells.clear()
            grid.innerHTML = ''

            // Calculate required grid size
            const maxRow = Math.max(
                ...loadedData.filledCells.map(cell => cell.row),
                ...loadedData.specialCells.map(cell => cell.row)
            )
            const maxCol = Math.max(
                ...loadedData.filledCells.map(cell => cell.col),
                ...loadedData.specialCells.map(cell => cell.col)
            )

            const requiredGridSize = Math.max(maxRow, maxCol, gridSize) + 1

            if (requiredGridSize > gridSize) {
                grid.style.width = `${requiredGridSize * cellSize}px`
                grid.style.height = `${requiredGridSize * cellSize}px`
            }

            // First, create and fill all the blue cells
            loadedData.filledCells.forEach(({ row, col }) => {
                const cell = createCell(row, col)
                cell.classList.add('filled')
                updateBorders(cell, row, col)
            })

            // Then, add special elements
            for (const cellData of loadedData.specialCells) {
                const { row, col, type, isSecret, isRevealed, direction } = cellData
                const cell = createCell(row, col)

                if (!cell) continue

                if (type === 'diagonal') {
                    cell.classList.add(`diagonal-${direction}`, 'filled')
                    updateBorders(cell, row, col)
                    continue
                }

                cell.classList.add('filled')
                const icons = getIconClass(type)
                const isRpgIconAvailable = await checkIconAvailability(icons.ra)

                const iconElement = document.createElement('i')
                if (isRpgIconAvailable) {
                    iconElement.className = `ra ${icons.ra}`
                } else {
                    iconElement.className = 'material-icons'
                    iconElement.textContent = icons.material
                }

                if (isSecret) {
                    cell.classList.add('secret-element')
                    if (isRevealed) {
                        cell.classList.add('revealed')
                    }
                    const secretContainer = document.createElement('div')
                    secretContainer.className = 'secret-container'
                    secretContainer.appendChild(iconElement)
                    cell.appendChild(secretContainer)

                    cell.addEventListener('click', e => {
                        e.stopPropagation()
                        cell.classList.toggle('revealed')
                    })
                } else {
                    cell.appendChild(iconElement)
                }

                updateBorders(cell, row, col)
            }

            // Update visible cells and redraw coordinate labels
            updateVisibleCells()
            updateGridTransform()
        }

        // Event Listeners
        gridContainer.addEventListener('wheel', e => {
            e.preventDefault()
            const delta = e.deltaY > 0 ? 0.9 : 1.1
            const newScale = scale * delta
            if (newScale >= 0.5 && newScale <= 3) {
                const rect = gridContainer.getBoundingClientRect()
                const mouseX = e.clientX - rect.left - 20 // Subtract 20px offset
                const mouseY = e.clientY - rect.top - 20 // Subtract 20px offset

                const gridX = mouseX / scale - translateX
                const gridY = mouseY / scale - translateY

                translateX -= gridX * (delta - 1)
                translateY -= gridY * (delta - 1)

                scale = newScale
                updateGridTransform()
            }
        })

        gridContainer.addEventListener('mousedown', e => {
            isDragging = true
            const rect = gridContainer.getBoundingClientRect()
            lastX = e.clientX - rect.left - 20 // Subtract 20px offset
            lastY = e.clientY - rect.top - 20 // Subtract 20px offset
        })

     

        gridContainer.addEventListener('mousemove', e => {
    if (isDragging) {
        e.preventDefault();
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;

        handlePan(dx, dy);
        
        lastX = e.clientX;
        lastY = e.clientY;
    }
});

        gridContainer.addEventListener('mouseup', () => {
            isDragging = false
        })

        gridContainer.addEventListener('mouseleave', () => {
            isDragging = false
        })

        let lastDistance = 0
        gridContainer.addEventListener('touchstart', e => {
            const rect = gridContainer.getBoundingClientRect()
            if (e.touches.length === 2) {
                const touch1 = e.touches[0]
                const touch2 = e.touches[1]
                lastDistance = Math.hypot(
                    touch1.clientX - touch2.clientX,
                    touch1.clientY - touch2.clientY
                )
            } else if (e.touches.length === 1) {
                isDragging = true
                lastX = e.touches[0].clientX - rect.left - 20 // Subtract 20px offset
                lastY = e.touches[0].clientY - rect.top - 20 // Subtract 20px offset
            }
        })

       

        gridContainer.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 2) {
        // Handle pinch-zoom
        const distance = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
        );
        
        const delta = distance / lastDistance;
        const newScale = scale * delta;
        
        if (newScale >= 0.5 && newScale <= 3) {
            const rect = gridContainer.getBoundingClientRect();
            const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left - 20;
            const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top - 20;

            const gridX = centerX / scale - translateX;
            const gridY = centerY / scale - translateY;

            translateX -= gridX * (delta - 1);
            translateY -= gridY * (delta - 1);

            scale = newScale;
            
            requestAnimationFrame(() => {
                updateGridTransform();
            });
        }
        lastDistance = distance;
    } else if (e.touches.length === 1 && isDragging) {
        const dx = e.touches[0].clientX - lastX;
        const dy = e.touches[0].clientY - lastY;
        
        handlePan(dx, dy);
        
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
    }
});

        gridContainer.addEventListener('touchend', () => {
            isDragging = false
        })

        readyBtn.addEventListener('click', () => {
            startMenu.style.display = 'none'
            // Instead of createGrid(), just update the visible cells
            updateVisibleCells()
        })

        document.addEventListener('click', e => {
            if (!fabBtn.contains(e.target) && !fabMenu.contains(e.target)) {
                fabMenu.style.display = 'none'
                const mapElementsSubmenu =
                    document.getElementById('mapElementsSubmenu')
                if (mapElementsSubmenu) {
                    mapElementsSubmenu.style.display = 'none'
                }
                currentMode = 'fill'
            }
        })

        window.addEventListener('resize', createGrid)


        async function initializeApp() {
            await createFabMenu()
            createDiagonalRotateFab()
            createElementsRotateFab()
            setupEventListeners()
            setupLegend()
        }

        // Call this function when the document is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp()
            createGrid() // Create the grid immediately
            initializePanControls();
            createNotesOverlay();
            addNotesButton();
        })
    </script>
</body>

</html>
